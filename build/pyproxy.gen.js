"use strict";
// This file is generated by applying the C preprocessor to core/pyproxy.js
// It uses the macros defined in core/pyproxy.c
// Do not edit it directly!
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.PyBuffer = exports.isPyProxy = void 0;
/**
 * Every public Python entrypoint goes through this file! The main entrypoint is
 * the callPyObject method, but of course one can also execute arbitrary code
 * via the various __dundermethods__ associated to classes.
 *
 * Any time we call into wasm, the call should be wrapped in a try catch block.
 * This way if a JavaScript error emerges from the wasm, we can escalate it to a
 * fatal error.
 *
 * This is file is preprocessed with -imacros "pyproxy.c". As a result of this,
 * any macros available in pyproxy.c are available here. We only need the flags
 * macros HAS_LENGTH, etc.
 *
 * See Makefile recipe for src/js/pyproxy.js
 */
var module_js_1 = require("./module.js");
/**
 * Is the argument a :any:`PyProxy`?
 * @param jsobj {any} Object to test.
 * @returns {jsobj is PyProxy} Is ``jsobj`` a :any:`PyProxy`?
 */
function isPyProxy(jsobj) {
    return !!jsobj && jsobj.$$ !== undefined && jsobj.$$.type === "PyProxy";
}
exports.isPyProxy = isPyProxy;
module_js_1.Module.isPyProxy = isPyProxy;
if (globalThis.FinalizationRegistry) {
    module_js_1.Module.finalizationRegistry = new FinalizationRegistry(function (_a) {
        var ptr = _a[0], cache = _a[1];
        cache.leaked = (!!1);
        pyproxy_decref_cache(cache);
        try {
            module_js_1.Module._Py_DecRef(ptr);
        }
        catch (e) {
            // I'm not really sure what happens if an error occurs inside of a
            // finalizer...
            module_js_1.Module.fatal_error(e);
        }
    });
    // For some unclear reason this code screws up selenium FirefoxDriver. Works
    // fine in chrome and when I test it in browser. It seems to be sensitive to
    // changes that don't make a difference to the semantics.
    // TODO: after 0.18.0, fix selenium issues with this code.
    // Module.bufferFinalizationRegistry = new FinalizationRegistry((ptr) => {
    //   try {
    //     Module._PyBuffer_Release(ptr);
    //     Module._PyMem_Free(ptr);
    //   } catch (e) {
    //     Module.fatal_error(e);
    //   }
    // });
}
else {
    module_js_1.Module.finalizationRegistry = { register: function () { }, unregister: function () { } };
    // Module.bufferFinalizationRegistry = finalizationRegistry;
}
var pyproxy_alloc_map = new Map();
module_js_1.Module.pyproxy_alloc_map = pyproxy_alloc_map;
var trace_pyproxy_alloc;
var trace_pyproxy_dealloc;
module_js_1.Module.enable_pyproxy_allocation_tracing = function () {
    trace_pyproxy_alloc = function (proxy) {
        pyproxy_alloc_map.set(proxy, Error().stack);
    };
    trace_pyproxy_dealloc = function (proxy) {
        pyproxy_alloc_map["delete"](proxy);
    };
};
module_js_1.Module.disable_pyproxy_allocation_tracing = function () {
    trace_pyproxy_alloc = function (proxy) { };
    trace_pyproxy_dealloc = function (proxy) { };
};
module_js_1.Module.disable_pyproxy_allocation_tracing();
/**
 * Create a new PyProxy wraping ptrobj which is a PyObject*.
 *
 * The argument cache is only needed to implement the PyProxy.copy API, it
 * allows the copy of the PyProxy to share its attribute cache with the original
 * version. In all other cases, pyproxy_new should be called with one argument.
 *
 * In the case that the Python object is callable, PyProxyClass inherits from
 * Function so that PyProxy objects can be callable. In that case we MUST expose
 * certain properties inherited from Function, but we do our best to remove as
 * many as possible.
 * @private
 */
module_js_1.Module.pyproxy_new = function (ptrobj, cache) {
    var flags = module_js_1.Module._pyproxy_getflags(ptrobj);
    var cls = module_js_1.Module.getPyProxyClass(flags);
    // Reflect.construct calls the constructor of Module.PyProxyClass but sets
    // the prototype as cls.prototype. This gives us a way to dynamically create
    // subclasses of PyProxyClass (as long as we don't need to use the "new
    // cls(ptrobj)" syntax).
    var target;
    if (flags & (1 << 8)) {
        // To make a callable proxy, we must call the Function constructor.
        // In this case we are effectively subclassing Function.
        target = Reflect.construct(Function, [], cls);
        // Remove undesirable properties added by Function constructor. Note: we
        // can't remove "arguments" or "caller" because they are not configurable
        // and not writable
        delete target.length;
        delete target.name;
        // prototype isn't configurable so we can't delete it but it's writable.
        target.prototype = undefined;
    }
    else {
        target = Object.create(cls.prototype);
    }
    if (!cache) {
        // The cache needs to be accessed primarily from the C function
        // _pyproxy_getattr so we make a hiwire id.
        var cacheId = module_js_1.Module.hiwire.new_value(new Map());
        cache = { cacheId: cacheId, refcnt: 0 };
    }
    cache.refcnt++;
    Object.defineProperty(target, "$$", {
        value: { ptr: ptrobj, type: "PyProxy", cache: cache }
    });
    module_js_1.Module._Py_IncRef(ptrobj);
    var proxy = new Proxy(target, PyProxyHandlers);
    trace_pyproxy_alloc(proxy);
    module_js_1.Module.finalizationRegistry.register(proxy, [ptrobj, cache], proxy);
    return proxy;
};
function _getPtr(jsobj) {
    var ptr = jsobj.$$.ptr;
    if (ptr === null) {
        throw new Error(jsobj.$$.destroyed_msg);
    }
    return ptr;
}
var pyproxyClassMap = new Map();
/**
 * Retreive the appropriate mixins based on the features requested in flags.
 * Used by pyproxy_new. The "flags" variable is produced by the C function
 * pyproxy_getflags. Multiple PyProxies with the same set of feature flags
 * will share the same prototype, so the memory footprint of each individual
 * PyProxy is minimal.
 * @private
 */
module_js_1.Module.getPyProxyClass = function (flags) {
    var result = pyproxyClassMap.get(flags);
    if (result) {
        return result;
    }
    var descriptors = {};
    for (var _i = 0, _a = [
        [(1 << 0), PyProxyLengthMethods],
        [(1 << 1), PyProxyGetItemMethods],
        [(1 << 2), PyProxySetItemMethods],
        [(1 << 3), PyProxyContainsMethods],
        [(1 << 4), PyProxyIterableMethods],
        [(1 << 5), PyProxyIteratorMethods],
        [(1 << 6), PyProxyAwaitableMethods],
        [(1 << 7), PyProxyBufferMethods],
        [(1 << 8), PyProxyCallableMethods],
    ]; _i < _a.length; _i++) {
        var _b = _a[_i], feature_flag = _b[0], methods = _b[1];
        if (flags & feature_flag) {
            Object.assign(descriptors, Object.getOwnPropertyDescriptors(methods.prototype));
        }
    }
    // Use base constructor (just throws an error if construction is attempted).
    descriptors.constructor = Object.getOwnPropertyDescriptor(PyProxyClass.prototype, "constructor");
    Object.assign(descriptors, Object.getOwnPropertyDescriptors({ $$flags: flags }));
    var new_proto = Object.create(PyProxyClass.prototype, descriptors);
    function NewPyProxyClass() { }
    NewPyProxyClass.prototype = new_proto;
    pyproxyClassMap.set(flags, NewPyProxyClass);
    return NewPyProxyClass;
};
// Static methods
module_js_1.Module.PyProxy_getPtr = _getPtr;
var pyproxy_cache_destroyed_msg = "This borrowed attribute proxy was automatically destroyed in the " +
    "process of destroying the proxy it was borrowed from. Try using the 'copy' method.";
function pyproxy_decref_cache(cache) {
    if (!cache) {
        return;
    }
    cache.refcnt--;
    if (cache.refcnt === 0) {
        var cache_map = module_js_1.Module.hiwire.pop_value(cache.cacheId);
        for (var _i = 0, _a = cache_map.values(); _i < _a.length; _i++) {
            var proxy_id = _a[_i];
            var cache_entry = module_js_1.Module.hiwire.pop_value(proxy_id);
            if (!cache.leaked) {
                module_js_1.Module.pyproxy_destroy(cache_entry, pyproxy_cache_destroyed_msg);
            }
        }
    }
}
module_js_1.Module.pyproxy_destroy = function (proxy, destroyed_msg) {
    if (proxy.$$.ptr === null) {
        return;
    }
    var ptrobj = _getPtr(proxy);
    module_js_1.Module.finalizationRegistry.unregister(proxy);
    destroyed_msg = destroyed_msg || "Object has already been destroyed";
    var proxy_type = proxy.type;
    var proxy_repr;
    try {
        proxy_repr = proxy.toString();
    }
    catch (e) {
        if (e.pyodide_fatal_error) {
            throw e;
        }
    }
    // Maybe the destructor will call JavaScript code that will somehow try
    // to use this proxy. Mark it deleted before decrementing reference count
    // just in case!
    proxy.$$.ptr = null;
    destroyed_msg += "\n" + "The object was of type \"".concat(proxy_type, "\" and ");
    if (proxy_repr) {
        destroyed_msg += "had repr \"".concat(proxy_repr, "\"");
    }
    else {
        destroyed_msg += "an error was raised when trying to generate its repr";
    }
    proxy.$$.destroyed_msg = destroyed_msg;
    pyproxy_decref_cache(proxy.$$.cache);
    try {
        module_js_1.Module._Py_DecRef(ptrobj);
        trace_pyproxy_dealloc(proxy);
    }
    catch (e) {
        module_js_1.Module.fatal_error(e);
    }
};
// Now a lot of boilerplate to wrap the abstract Object protocol wrappers
// defined in pyproxy.c in JavaScript functions.
module_js_1.Module.callPyObjectKwargs = function (ptrobj) {
    var jsargs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        jsargs[_i - 1] = arguments[_i];
    }
    // We don't do any checking for kwargs, checks are in PyProxy.callKwargs
    // which only is used when the keyword arguments come from the user.
    var kwargs = jsargs.pop();
    var num_pos_args = jsargs.length;
    var kwargs_names = Object.keys(kwargs);
    var kwargs_values = Object.values(kwargs);
    var num_kwargs = kwargs_names.length;
    jsargs.push.apply(jsargs, kwargs_values);
    var idargs = module_js_1.Module.hiwire.new_value(jsargs);
    var idkwnames = module_js_1.Module.hiwire.new_value(kwargs_names);
    var idresult;
    try {
        idresult = module_js_1.Module.__pyproxy_apply(ptrobj, idargs, num_pos_args, idkwnames, num_kwargs);
    }
    catch (e) {
        module_js_1.Module.fatal_error(e);
    }
    finally {
        module_js_1.Module.hiwire.decref(idargs);
        module_js_1.Module.hiwire.decref(idkwnames);
    }
    if (idresult === 0) {
        module_js_1.Module._pythonexc2js();
    }
    return module_js_1.Module.hiwire.pop_value(idresult);
};
module_js_1.Module.callPyObject = function (ptrobj) {
    var jsargs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        jsargs[_i - 1] = arguments[_i];
    }
    return module_js_1.Module.callPyObjectKwargs.apply(module_js_1.Module, __spreadArray(__spreadArray([ptrobj], jsargs, false), [{}], false));
};
/**
 * @typedef {(PyProxyClass & {[x : string] : Py2JsResult})} PyProxy
 * @typedef { PyProxy | number | bigint | string | boolean | undefined } Py2JsResult
 */
var PyProxyClass = /** @class */ (function () {
    function PyProxyClass() {
        throw new TypeError("PyProxy is not a constructor");
    }
    Object.defineProperty(PyProxyClass.prototype, Symbol.toStringTag, {
        get: function () {
            return "PyProxy";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PyProxyClass.prototype, "type", {
        /**
         * The name of the type of the object.
         *
         * Usually the value is ``"module.name"`` but for builtins or
         * interpreter-defined types it is just ``"name"``. As pseudocode this is:
         *
         * .. code-block:: python
         *
         *    ty = type(x)
         *    if ty.__module__ == 'builtins' or ty.__module__ == "__main__":
         *        return ty.__name__
         *    else:
         *        ty.__module__ + "." + ty.__name__
         *
         * @type {string}
         */
        get: function () {
            var ptrobj = _getPtr(this);
            return module_js_1.Module.hiwire.pop_value(module_js_1.Module.__pyproxy_type(ptrobj));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @returns {string}
     */
    PyProxyClass.prototype.toString = function () {
        var ptrobj = _getPtr(this);
        var jsref_repr;
        try {
            jsref_repr = module_js_1.Module.__pyproxy_repr(ptrobj);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        if (jsref_repr === 0) {
            module_js_1.Module._pythonexc2js();
        }
        return module_js_1.Module.hiwire.pop_value(jsref_repr);
    };
    /**
     * Destroy the ``PyProxy``. This will release the memory. Any further
     * attempt to use the object will raise an error.
     *
     * In a browser supporting `FinalizationRegistry
     * <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry>`_
     * Pyodide will automatically destroy the ``PyProxy`` when it is garbage
     * collected, however there is no guarantee that the finalizer will be run
     * in a timely manner so it is better to ``destroy`` the proxy explicitly.
     *
     * @param {string} [destroyed_msg] The error message to print if use is
     *        attempted after destroying. Defaults to "Object has already been
     *        destroyed".
     */
    PyProxyClass.prototype.destroy = function (destroyed_msg) {
        module_js_1.Module.pyproxy_destroy(this, destroyed_msg);
    };
    /**
     * Make a new PyProxy pointing to the same Python object.
     * Useful if the PyProxy is destroyed somewhere else.
     * @returns {PyProxy}
     */
    PyProxyClass.prototype.copy = function () {
        var ptrobj = _getPtr(this);
        return module_js_1.Module.pyproxy_new(ptrobj, this.$$.cache);
    };
    /**
     * Converts the ``PyProxy`` into a JavaScript object as best as possible. By
     * default does a deep conversion, if a shallow conversion is desired, you can
     * use ``proxy.toJs({depth : 1})``. See :ref:`Explicit Conversion of PyProxy
     * <type-translations-pyproxy-to-js>` for more info.
     *
     * @param {object} options
     * @param {number} [options.depth] How many layers deep to perform the
     * conversion. Defaults to infinite.
     * @param {array} [options.pyproxies] If provided, ``toJs`` will store all
     * PyProxies created in this list. This allows you to easily destroy all the
     * PyProxies by iterating the list without having to recurse over the
     * generated structure. The most common use case is to create a new empty
     * list, pass the list as `pyproxies`, and then later iterate over `pyproxies`
     * to destroy all of created proxies.
     * @param {boolean} [options.create_pyproxies] If false, ``toJs`` will throw a
     * ``ConversionError`` rather than producing a ``PyProxy``.
     * @param {boolean} [options.dict_converter] A function to be called on an
     * iterable of pairs ``[key, value]``. Convert this iterable of pairs to the
     * desired output. For instance, ``Object.fromEntries`` would convert the dict
     * to an object, ``Array.from`` converts it to an array of entries, and ``(it) =>
     * new Map(it)`` converts it to a ``Map`` (which is the default behavior).
     * @return {any} The JavaScript object resulting from the conversion.
     */
    PyProxyClass.prototype.toJs = function (_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.depth, depth = _c === void 0 ? -1 : _c, pyproxies = _b.pyproxies, _d = _b.create_pyproxies, create_pyproxies = _d === void 0 ? (!!1) : _d, dict_converter = _b.dict_converter;
        var ptrobj = _getPtr(this);
        var idresult;
        var proxies_id;
        var dict_converter_id = 0;
        if (!create_pyproxies) {
            proxies_id = 0;
        }
        else if (pyproxies) {
            proxies_id = module_js_1.Module.hiwire.new_value(pyproxies);
        }
        else {
            proxies_id = module_js_1.Module.hiwire.new_value([]);
        }
        if (dict_converter) {
            dict_converter_id = module_js_1.Module.hiwire.new_value(dict_converter);
        }
        try {
            idresult = module_js_1.Module._python2js_custom_dict_converter(ptrobj, depth, proxies_id, dict_converter_id);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        finally {
            module_js_1.Module.hiwire.decref(proxies_id);
            module_js_1.Module.hiwire.decref(dict_converter_id);
        }
        if (idresult === 0) {
            module_js_1.Module._pythonexc2js();
        }
        return module_js_1.Module.hiwire.pop_value(idresult);
    };
    /**
     * Check whether the :any:`PyProxy.length` getter is available on this PyProxy. A
     * Typescript type guard.
     * @returns {this is PyProxyWithLength}
     */
    PyProxyClass.prototype.supportsLength = function () {
        return !!(this.$$flags & (1 << 0));
    };
    /**
     * Check whether the :any:`PyProxy.get` method is available on this PyProxy. A
     * Typescript type guard.
     * @returns {this is PyProxyWithGet}
     */
    PyProxyClass.prototype.supportsGet = function () {
        return !!(this.$$flags & (1 << 1));
    };
    /**
     * Check whether the :any:`PyProxy.set` method is available on this PyProxy. A
     * Typescript type guard.
     * @returns {this is PyProxyWithSet}
     */
    PyProxyClass.prototype.supportsSet = function () {
        return !!(this.$$flags & (1 << 2));
    };
    /**
     * Check whether the :any:`PyProxy.has` method is available on this PyProxy. A
     * Typescript type guard.
     * @returns {this is PyProxyWithHas}
     */
    PyProxyClass.prototype.supportsHas = function () {
        return !!(this.$$flags & (1 << 3));
    };
    /**
     * Check whether the PyProxy is iterable. A Typescript type guard for
     * :any:`PyProxy.[Symbol.iterator]`.
     * @returns {this is PyProxyIterable}
     */
    PyProxyClass.prototype.isIterable = function () {
        return !!(this.$$flags & ((1 << 4) | (1 << 5)));
    };
    /**
     * Check whether the PyProxy is iterable. A Typescript type guard for
     * :any:`PyProxy.next`.
     * @returns {this is PyProxyIterator}
     */
    PyProxyClass.prototype.isIterator = function () {
        return !!(this.$$flags & (1 << 5));
    };
    /**
     * Check whether the PyProxy is awaitable. A Typescript type guard, if this
     * function returns true Typescript considers the PyProxy to be a ``Promise``.
     * @returns {this is PyProxyAwaitable}
     */
    PyProxyClass.prototype.isAwaitable = function () {
        return !!(this.$$flags & (1 << 6));
    };
    /**
     * Check whether the PyProxy is a buffer. A Typescript type guard for
     * :any:`PyProxy.getBuffer`.
     * @returns {this is PyProxyBuffer}
     */
    PyProxyClass.prototype.isBuffer = function () {
        return !!(this.$$flags & (1 << 7));
    };
    /**
     * Check whether the PyProxy is a Callable. A Typescript type guard, if this
     * returns true then Typescript considers the Proxy to be callable of
     * signature ``(args... : any[]) => PyProxy | number | bigint | string |
     * boolean | undefined``.
     * @returns {this is PyProxyCallable}
     */
    PyProxyClass.prototype.isCallable = function () {
        return !!(this.$$flags & (1 << 8));
    };
    return PyProxyClass;
}());
/**
 * @typedef { PyProxy & PyProxyLengthMethods } PyProxyWithLength
 */
// Controlled by HAS_LENGTH, appears for any object with __len__ or sq_length
// or mp_length methods
var PyProxyLengthMethods = /** @class */ (function () {
    function PyProxyLengthMethods() {
    }
    Object.defineProperty(PyProxyLengthMethods.prototype, "length", {
        /**
         * The length of the object.
         *
         * Present only if the proxied Python object has a ``__len__`` method.
         * @returns {number}
         */
        get: function () {
            var ptrobj = _getPtr(this);
            var length;
            try {
                length = module_js_1.Module._PyObject_Size(ptrobj);
            }
            catch (e) {
                module_js_1.Module.fatal_error(e);
            }
            if (length === -1) {
                module_js_1.Module._pythonexc2js();
            }
            return length;
        },
        enumerable: false,
        configurable: true
    });
    return PyProxyLengthMethods;
}());
/**
 * @typedef {PyProxy & PyProxyGetItemMethods} PyProxyWithGet
 */
// Controlled by HAS_GET, appears for any class with __getitem__,
// mp_subscript, or sq_item methods
/**
 * @interface
 */
var PyProxyGetItemMethods = /** @class */ (function () {
    function PyProxyGetItemMethods() {
    }
    /**
     * This translates to the Python code ``obj[key]``.
     *
     * Present only if the proxied Python object has a ``__getitem__`` method.
     *
     * @param {any} key The key to look up.
     * @returns {Py2JsResult} The corresponding value.
     */
    PyProxyGetItemMethods.prototype.get = function (key) {
        var ptrobj = _getPtr(this);
        var idkey = module_js_1.Module.hiwire.new_value(key);
        var idresult;
        try {
            idresult = module_js_1.Module.__pyproxy_getitem(ptrobj, idkey);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        finally {
            module_js_1.Module.hiwire.decref(idkey);
        }
        if (idresult === 0) {
            if (module_js_1.Module._PyErr_Occurred()) {
                module_js_1.Module._pythonexc2js();
            }
            else {
                return undefined;
            }
        }
        return module_js_1.Module.hiwire.pop_value(idresult);
    };
    return PyProxyGetItemMethods;
}());
/**
 * @typedef {PyProxy & PyProxySetItemMethods} PyProxyWithSet
 */
// Controlled by HAS_SET, appears for any class with __setitem__, __delitem__,
// mp_ass_subscript,  or sq_ass_item.
var PyProxySetItemMethods = /** @class */ (function () {
    function PyProxySetItemMethods() {
    }
    /**
     * This translates to the Python code ``obj[key] = value``.
     *
     * Present only if the proxied Python object has a ``__setitem__`` method.
     *
     * @param {any} key The key to set.
     * @param {any} value The value to set it to.
     */
    PyProxySetItemMethods.prototype.set = function (key, value) {
        var ptrobj = _getPtr(this);
        var idkey = module_js_1.Module.hiwire.new_value(key);
        var idval = module_js_1.Module.hiwire.new_value(value);
        var errcode;
        try {
            errcode = module_js_1.Module.__pyproxy_setitem(ptrobj, idkey, idval);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        finally {
            module_js_1.Module.hiwire.decref(idkey);
            module_js_1.Module.hiwire.decref(idval);
        }
        if (errcode === -1) {
            module_js_1.Module._pythonexc2js();
        }
    };
    /**
     * This translates to the Python code ``del obj[key]``.
     *
     * Present only if the proxied Python object has a ``__delitem__`` method.
     *
     * @param {any} key The key to delete.
     */
    PyProxySetItemMethods.prototype["delete"] = function (key) {
        var ptrobj = _getPtr(this);
        var idkey = module_js_1.Module.hiwire.new_value(key);
        var errcode;
        try {
            errcode = module_js_1.Module.__pyproxy_delitem(ptrobj, idkey);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        finally {
            module_js_1.Module.hiwire.decref(idkey);
        }
        if (errcode === -1) {
            module_js_1.Module._pythonexc2js();
        }
    };
    return PyProxySetItemMethods;
}());
/**
 * @typedef {PyProxy & PyProxyContainsMethods} PyProxyWithHas
 */
// Controlled by HAS_CONTAINS flag, appears for any class with __contains__ or
// sq_contains
var PyProxyContainsMethods = /** @class */ (function () {
    function PyProxyContainsMethods() {
    }
    /**
     * This translates to the Python code ``key in obj``.
     *
     * Present only if the proxied Python object has a ``__contains__`` method.
     *
     * @param {*} key The key to check for.
     * @returns {boolean} Is ``key`` present?
     */
    PyProxyContainsMethods.prototype.has = function (key) {
        var ptrobj = _getPtr(this);
        var idkey = module_js_1.Module.hiwire.new_value(key);
        var result;
        try {
            result = module_js_1.Module.__pyproxy_contains(ptrobj, idkey);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        finally {
            module_js_1.Module.hiwire.decref(idkey);
        }
        if (result === -1) {
            module_js_1.Module._pythonexc2js();
        }
        return result === 1;
    };
    return PyProxyContainsMethods;
}());
/**
 * A helper for [Symbol.iterator].
 *
 * Because "it is possible for a generator to be garbage collected without
 * ever running its finally block", we take extra care to try to ensure that
 * we don't leak the iterator. We register it with the finalizationRegistry,
 * but if the finally block is executed, we decref the pointer and unregister.
 *
 * In order to do this, we create the generator with this inner method,
 * register the finalizer, and then return it.
 *
 * Quote from:
 * https://hacks.mozilla.org/2015/07/es6-in-depth-generators-continued/
 *
 * @private
 */
function iter_helper(iterptr, token) {
    var item, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 4, 5, 6]);
                item = void 0;
                _a.label = 1;
            case 1:
                if (!(item = module_js_1.Module.__pyproxy_iter_next(iterptr))) return [3 /*break*/, 3];
                return [4 /*yield*/, module_js_1.Module.hiwire.pop_value(item)];
            case 2:
                _a.sent();
                return [3 /*break*/, 1];
            case 3: return [3 /*break*/, 6];
            case 4:
                e_1 = _a.sent();
                module_js_1.Module.fatal_error(e_1);
                return [3 /*break*/, 6];
            case 5:
                module_js_1.Module.finalizationRegistry.unregister(token);
                module_js_1.Module._Py_DecRef(iterptr);
                return [7 /*endfinally*/];
            case 6:
                if (module_js_1.Module._PyErr_Occurred()) {
                    module_js_1.Module._pythonexc2js();
                }
                return [2 /*return*/];
        }
    });
}
/**
 * @typedef {PyProxy & PyProxyIterableMethods} PyProxyIterable
 */
// Controlled by IS_ITERABLE, appears for any object with __iter__ or tp_iter,
// unless they are iterators. See: https://docs.python.org/3/c-api/iter.html
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
// This avoids allocating a PyProxy wrapper for the temporary iterator.
var PyProxyIterableMethods = /** @class */ (function () {
    function PyProxyIterableMethods() {
    }
    /**
     * This translates to the Python code ``iter(obj)``. Return an iterator
     * associated to the proxy. See the documentation for `Symbol.iterator
     * <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator>`_.
     *
     * Present only if the proxied Python object is iterable (i.e., has an
     * ``__iter__`` method).
     *
     * This will be used implicitly by ``for(let x of proxy){}``.
     *
     * @returns {Iterator<Py2JsResult, Py2JsResult, any>} An iterator for the proxied Python object.
     */
    PyProxyIterableMethods.prototype[Symbol.iterator] = function () {
        var ptrobj = _getPtr(this);
        var token = {};
        var iterptr;
        try {
            iterptr = module_js_1.Module._PyObject_GetIter(ptrobj);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        if (iterptr === 0) {
            module_js_1.Module._pythonexc2js();
        }
        var result = iter_helper(iterptr, token);
        module_js_1.Module.finalizationRegistry.register(result, [iterptr, undefined], token);
        return result;
    };
    return PyProxyIterableMethods;
}());
/**
 * @typedef {PyProxy & PyProxyIteratorMethods} PyProxyIterator
 */
// Controlled by IS_ITERATOR, appears for any object with a __next__ or
// tp_iternext method.
var PyProxyIteratorMethods = /** @class */ (function () {
    function PyProxyIteratorMethods() {
    }
    PyProxyIteratorMethods.prototype[Symbol.iterator] = function () {
        return this;
    };
    /**
     * This translates to the Python code ``next(obj)``. Returns the next value
     * of the generator. See the documentation for `Generator.prototype.next
     * <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next>`_.
     * The argument will be sent to the Python generator.
     *
     * This will be used implicitly by ``for(let x of proxy){}``.
     *
     * Present only if the proxied Python object is a generator or iterator
     * (i.e., has a ``send`` or ``__next__`` method).
     *
     * @param {any=} [value] The value to send to the generator. The value will be
     * assigned as a result of a yield expression.
     * @returns {IteratorResult<Py2JsResult, Py2JsResult>} An Object with two properties: ``done`` and ``value``.
     * When the generator yields ``some_value``, ``next`` returns ``{done :
     * false, value : some_value}``. When the generator raises a
     * ``StopIteration(result_value)`` exception, ``next`` returns ``{done :
     * true, value : result_value}``.
     */
    PyProxyIteratorMethods.prototype.next = function (arg) {
        if (arg === void 0) { arg = undefined; }
        var idresult;
        // Note: arg is optional, if arg is not supplied, it will be undefined
        // which gets converted to "Py_None". This is as intended.
        var idarg = module_js_1.Module.hiwire.new_value(arg);
        var done;
        try {
            idresult = module_js_1.Module.__pyproxyGen_Send(_getPtr(this), idarg);
            done = idresult === 0;
            if (done) {
                idresult = module_js_1.Module.__pyproxyGen_FetchStopIterationValue();
            }
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        finally {
            module_js_1.Module.hiwire.decref(idarg);
        }
        if (done && idresult === 0) {
            module_js_1.Module._pythonexc2js();
        }
        var value = module_js_1.Module.hiwire.pop_value(idresult);
        return { done: done, value: value };
    };
    return PyProxyIteratorMethods;
}());
// Another layer of boilerplate. The PyProxyHandlers have some annoying logic
// to deal with straining out the spurious "Function" properties "prototype",
// "arguments", and "length", to deal with correctly satisfying the Proxy
// invariants, and to deal with the mro
function python_hasattr(jsobj, jskey) {
    var ptrobj = _getPtr(jsobj);
    var idkey = module_js_1.Module.hiwire.new_value(jskey);
    var result;
    try {
        result = module_js_1.Module.__pyproxy_hasattr(ptrobj, idkey);
    }
    catch (e) {
        module_js_1.Module.fatal_error(e);
    }
    finally {
        module_js_1.Module.hiwire.decref(idkey);
    }
    if (result === -1) {
        module_js_1.Module._pythonexc2js();
    }
    return result !== 0;
}
// Returns a JsRef in order to allow us to differentiate between "not found"
// (in which case we return 0) and "found 'None'" (in which case we return
// Js_undefined).
function python_getattr(jsobj, jskey) {
    var ptrobj = _getPtr(jsobj);
    var idkey = module_js_1.Module.hiwire.new_value(jskey);
    var idresult;
    var cacheId = jsobj.$$.cache.cacheId;
    try {
        idresult = module_js_1.Module.__pyproxy_getattr(ptrobj, idkey, cacheId);
    }
    catch (e) {
        module_js_1.Module.fatal_error(e);
    }
    finally {
        module_js_1.Module.hiwire.decref(idkey);
    }
    if (idresult === 0) {
        if (module_js_1.Module._PyErr_Occurred()) {
            module_js_1.Module._pythonexc2js();
        }
    }
    return idresult;
}
function python_setattr(jsobj, jskey, jsval) {
    var ptrobj = _getPtr(jsobj);
    var idkey = module_js_1.Module.hiwire.new_value(jskey);
    var idval = module_js_1.Module.hiwire.new_value(jsval);
    var errcode;
    try {
        errcode = module_js_1.Module.__pyproxy_setattr(ptrobj, idkey, idval);
    }
    catch (e) {
        module_js_1.Module.fatal_error(e);
    }
    finally {
        module_js_1.Module.hiwire.decref(idkey);
        module_js_1.Module.hiwire.decref(idval);
    }
    if (errcode === -1) {
        module_js_1.Module._pythonexc2js();
    }
}
function python_delattr(jsobj, jskey) {
    var ptrobj = _getPtr(jsobj);
    var idkey = module_js_1.Module.hiwire.new_value(jskey);
    var errcode;
    try {
        errcode = module_js_1.Module.__pyproxy_delattr(ptrobj, idkey);
    }
    catch (e) {
        module_js_1.Module.fatal_error(e);
    }
    finally {
        module_js_1.Module.hiwire.decref(idkey);
    }
    if (errcode === -1) {
        module_js_1.Module._pythonexc2js();
    }
}
// See explanation of which methods should be defined here and what they do
// here:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
var PyProxyHandlers = {
    isExtensible: function () {
        return (!!1);
    },
    has: function (jsobj, jskey) {
        // Note: must report "prototype" in proxy when we are callable.
        // (We can return the wrong value from "get" handler though.)
        var objHasKey = Reflect.has(jsobj, jskey);
        if (objHasKey) {
            return (!!1);
        }
        // python_hasattr will crash if given a Symbol.
        if (typeof jskey === "symbol") {
            return (!!0);
        }
        if (jskey.startsWith("$")) {
            jskey = jskey.slice(1);
        }
        return python_hasattr(jsobj, jskey);
    },
    get: function (jsobj, jskey) {
        // Preference order:
        // 1. stuff from JavaScript
        // 2. the result of Python getattr
        // python_getattr will crash if given a Symbol.
        if (jskey in jsobj || typeof jskey === "symbol") {
            return Reflect.get(jsobj, jskey);
        }
        // If keys start with $ remove the $. User can use initial $ to
        // unambiguously ask for a key on the Python object.
        if (jskey.startsWith("$")) {
            jskey = jskey.slice(1);
        }
        // 2. The result of getattr
        var idresult = python_getattr(jsobj, jskey);
        if (idresult !== 0) {
            return module_js_1.Module.hiwire.pop_value(idresult);
        }
    },
    set: function (jsobj, jskey, jsval) {
        var descr = Object.getOwnPropertyDescriptor(jsobj, jskey);
        if (descr && !descr.writable) {
            throw new TypeError("Cannot set read only field '".concat(jskey, "'"));
        }
        // python_setattr will crash if given a Symbol.
        if (typeof jskey === "symbol") {
            return Reflect.set(jsobj, jskey, jsval);
        }
        if (jskey.startsWith("$")) {
            jskey = jskey.slice(1);
        }
        python_setattr(jsobj, jskey, jsval);
        return (!!1);
    },
    deleteProperty: function (jsobj, jskey) {
        var descr = Object.getOwnPropertyDescriptor(jsobj, jskey);
        if (descr && !descr.writable) {
            throw new TypeError("Cannot delete read only field '".concat(jskey, "'"));
        }
        if (typeof jskey === "symbol") {
            return Reflect.deleteProperty(jsobj, jskey);
        }
        if (jskey.startsWith("$")) {
            jskey = jskey.slice(1);
        }
        python_delattr(jsobj, jskey);
        // Must return "false" if "jskey" is a nonconfigurable own property.
        // Otherwise JavaScript will throw a TypeError.
        return !descr || descr.configurable;
    },
    ownKeys: function (jsobj) {
        var ptrobj = _getPtr(jsobj);
        var idresult;
        try {
            idresult = module_js_1.Module.__pyproxy_ownKeys(ptrobj);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        if (idresult === 0) {
            module_js_1.Module._pythonexc2js();
        }
        var result = module_js_1.Module.hiwire.pop_value(idresult);
        result.push.apply(result, Reflect.ownKeys(jsobj));
        return result;
    },
    apply: function (jsobj, jsthis, jsargs) {
        return jsobj.apply(jsthis, jsargs);
    }
};
/**
 * @typedef {PyProxy & Promise<Py2JsResult>} PyProxyAwaitable
 */
/**
 * The Promise / JavaScript awaitable API.
 * @private
 */
var PyProxyAwaitableMethods = /** @class */ (function () {
    function PyProxyAwaitableMethods() {
    }
    /**
     * This wraps __pyproxy_ensure_future and makes a function that converts a
     * Python awaitable to a promise, scheduling the awaitable on the Python
     * event loop if necessary.
     * @private
     */
    PyProxyAwaitableMethods.prototype._ensure_future = function () {
        if (this.$$.promise) {
            return this.$$.promise;
        }
        var ptrobj = _getPtr(this);
        var resolveHandle;
        var rejectHandle;
        var promise = new Promise(function (resolve, reject) {
            resolveHandle = resolve;
            rejectHandle = reject;
        });
        var resolve_handle_id = module_js_1.Module.hiwire.new_value(resolveHandle);
        var reject_handle_id = module_js_1.Module.hiwire.new_value(rejectHandle);
        var errcode;
        try {
            errcode = module_js_1.Module.__pyproxy_ensure_future(ptrobj, resolve_handle_id, reject_handle_id);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        finally {
            module_js_1.Module.hiwire.decref(reject_handle_id);
            module_js_1.Module.hiwire.decref(resolve_handle_id);
        }
        if (errcode === -1) {
            module_js_1.Module._pythonexc2js();
        }
        this.$$.promise = promise;
        this.destroy();
        return promise;
    };
    /**
     * Runs ``asyncio.ensure_future(awaitable)``, executes
     * ``onFulfilled(result)`` when the ``Future`` resolves successfully,
     * executes ``onRejected(error)`` when the ``Future`` fails. Will be used
     * implictly by ``await obj``.
     *
     * See the documentation for
     * `Promise.then
     * <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then>`_
     *
     * Present only if the proxied Python object is `awaitable
     * <https://docs.python.org/3/library/asyncio-task.html?highlight=awaitable#awaitables>`_.
     *
     * @param {Function} onFulfilled A handler called with the result as an
     * argument if the awaitable succeeds.
     * @param {Function} onRejected A handler called with the error as an
     * argument if the awaitable fails.
     * @returns {Promise} The resulting Promise.
     */
    PyProxyAwaitableMethods.prototype.then = function (onFulfilled, onRejected) {
        var promise = this._ensure_future();
        return promise.then(onFulfilled, onRejected);
    };
    /**
     * Runs ``asyncio.ensure_future(awaitable)`` and executes
     * ``onRejected(error)`` if the future fails.
     *
     * See the documentation for
     * `Promise.catch
     * <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch>`_.
     *
     * Present only if the proxied Python object is `awaitable
     * <https://docs.python.org/3/library/asyncio-task.html?highlight=awaitable#awaitables>`_.
     *
     * @param {Function} onRejected A handler called with the error as an
     * argument if the awaitable fails.
     * @returns {Promise} The resulting Promise.
     */
    PyProxyAwaitableMethods.prototype["catch"] = function (onRejected) {
        var promise = this._ensure_future();
        return promise["catch"](onRejected);
    };
    /**
     * Runs ``asyncio.ensure_future(awaitable)`` and executes
     * ``onFinally(error)`` when the future resolves.
     *
     * See the documentation for
     * `Promise.finally
     * <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally>`_.
     *
     * Present only if the proxied Python object is `awaitable
     * <https://docs.python.org/3/library/asyncio-task.html?highlight=awaitable#awaitables>`_.
     *
     *
     * @param {Function} onFinally A handler that is called with zero arguments
     * when the awaitable resolves.
     * @returns {Promise} A Promise that resolves or rejects with the same
     * result as the original Promise, but only after executing the
     * ``onFinally`` handler.
     */
    PyProxyAwaitableMethods.prototype["finally"] = function (onFinally) {
        var promise = this._ensure_future();
        return promise["finally"](onFinally);
    };
    return PyProxyAwaitableMethods;
}());
/**
 * @typedef { PyProxy & PyProxyCallableMethods & ((...args : any[]) => Py2JsResult) } PyProxyCallable
 */
var PyProxyCallableMethods = /** @class */ (function () {
    function PyProxyCallableMethods() {
    }
    PyProxyCallableMethods.prototype.apply = function (jsthis, jsargs) {
        return module_js_1.Module.callPyObject.apply(module_js_1.Module, __spreadArray([_getPtr(this)], jsargs, false));
    };
    PyProxyCallableMethods.prototype.call = function (jsthis) {
        var jsargs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            jsargs[_i - 1] = arguments[_i];
        }
        return module_js_1.Module.callPyObject.apply(module_js_1.Module, __spreadArray([_getPtr(this)], jsargs, false));
    };
    /**
     * Call the function with key word arguments.
     * The last argument must be an object with the keyword arguments.
     */
    PyProxyCallableMethods.prototype.callKwargs = function () {
        var jsargs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            jsargs[_i] = arguments[_i];
        }
        if (jsargs.length === 0) {
            throw new TypeError("callKwargs requires at least one argument (the key word argument object)");
        }
        var kwargs = jsargs[jsargs.length - 1];
        if (kwargs.constructor !== undefined &&
            kwargs.constructor.name !== "Object") {
            throw new TypeError("kwargs argument is not an object");
        }
        return module_js_1.Module.callPyObjectKwargs.apply(module_js_1.Module, __spreadArray([_getPtr(this)], jsargs, false));
    };
    return PyProxyCallableMethods;
}());
PyProxyCallableMethods.prototype.prototype = Function.prototype;
var type_to_array_map = new Map([
    ["i8", Int8Array],
    ["u8", Uint8Array],
    ["u8clamped", Uint8ClampedArray],
    ["i16", Int16Array],
    ["u16", Uint16Array],
    ["i32", Int32Array],
    ["u32", Uint32Array],
    ["i32", Int32Array],
    ["u32", Uint32Array],
    // if these aren't available, will be globalThis.BigInt64Array will be
    // undefined rather than raising a ReferenceError.
    ["i64", globalThis.BigInt64Array],
    ["u64", globalThis.BigUint64Array],
    ["f32", Float32Array],
    ["f64", Float64Array],
    ["dataview", DataView],
]);
/**
 * @typedef {PyProxy & PyProxyBufferMethods} PyProxyBuffer
 */
var PyProxyBufferMethods = /** @class */ (function () {
    function PyProxyBufferMethods() {
    }
    /**
     * Get a view of the buffer data which is usable from JavaScript. No copy is
     * ever performed.
     *
     * Present only if the proxied Python object supports the `Python Buffer
     * Protocol <https://docs.python.org/3/c-api/buffer.html>`_.
     *
     * We do not support suboffsets, if the buffer requires suboffsets we will
     * throw an error. JavaScript nd array libraries can't handle suboffsets
     * anyways. In this case, you should use the :any:`toJs` api or copy the
     * buffer to one that doesn't use suboffets (using e.g.,
     * `numpy.ascontiguousarray
     * <https://numpy.org/doc/stable/reference/generated/numpy.ascontiguousarray.html>`_).
     *
     * If the buffer stores big endian data or half floats, this function will
     * fail without an explicit type argument. For big endian data you can use
     * ``toJs``. `DataViews
     * <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView>`_
     * have support for big endian data, so you might want to pass
     * ``'dataview'`` as the type argument in that case.
     *
     * @param {string=} [type] The type of the :any:`PyBuffer.data <pyodide.PyBuffer.data>` field in the
     * output. Should be one of: ``"i8"``, ``"u8"``, ``"u8clamped"``, ``"i16"``,
     * ``"u16"``, ``"i32"``, ``"u32"``, ``"i32"``, ``"u32"``, ``"i64"``,
     * ``"u64"``, ``"f32"``, ``"f64``, or ``"dataview"``. This argument is
     * optional, if absent ``getBuffer`` will try to determine the appropriate
     * output type based on the buffer `format string
     * <https://docs.python.org/3/library/struct.html#format-strings>`_.
     * @returns {PyBuffer} :any:`PyBuffer <pyodide.PyBuffer>`
     */
    PyProxyBufferMethods.prototype.getBuffer = function (type) {
        var _a;
        var ArrayType = undefined;
        if (type) {
            ArrayType = type_to_array_map.get(type);
            if (ArrayType === undefined) {
                throw new Error("Unknown type ".concat(type));
            }
        }
        var HEAPU32 = module_js_1.Module.HEAPU32;
        var orig_stack_ptr = module_js_1.Module.stackSave();
        var buffer_struct_ptr = module_js_1.Module.stackAlloc(HEAPU32[(module_js_1.Module._buffer_struct_size >> 2) + 0]);
        var this_ptr = _getPtr(this);
        var errcode;
        try {
            errcode = module_js_1.Module.__pyproxy_get_buffer(buffer_struct_ptr, this_ptr);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        if (errcode === -1) {
            module_js_1.Module._pythonexc2js();
        }
        // This has to match the fields in buffer_struct
        var startByteOffset = HEAPU32[(buffer_struct_ptr >> 2) + 0];
        var minByteOffset = HEAPU32[(buffer_struct_ptr >> 2) + 1];
        var maxByteOffset = HEAPU32[(buffer_struct_ptr >> 2) + 2];
        var readonly = !!HEAPU32[(buffer_struct_ptr >> 2) + 3];
        var format_ptr = HEAPU32[(buffer_struct_ptr >> 2) + 4];
        var itemsize = HEAPU32[(buffer_struct_ptr >> 2) + 5];
        var shape = module_js_1.Module.hiwire.pop_value(HEAPU32[(buffer_struct_ptr >> 2) + 6]);
        var strides = module_js_1.Module.hiwire.pop_value(HEAPU32[(buffer_struct_ptr >> 2) + 7]);
        var view_ptr = HEAPU32[(buffer_struct_ptr >> 2) + 8];
        var c_contiguous = !!HEAPU32[(buffer_struct_ptr >> 2) + 9];
        var f_contiguous = !!HEAPU32[(buffer_struct_ptr >> 2) + 10];
        var format = module_js_1.Module.UTF8ToString(format_ptr);
        module_js_1.Module.stackRestore(orig_stack_ptr);
        var success = (!!0);
        try {
            var bigEndian = (!!0);
            if (ArrayType === undefined) {
                _a = module_js_1.Module.processBufferFormatString(format, " In this case, you can pass an explicit type argument."), ArrayType = _a[0], bigEndian = _a[1];
            }
            var alignment = parseInt(ArrayType.name.replace(/[^0-9]/g, "")) / 8 || 1;
            if (bigEndian && alignment > 1) {
                throw new Error("Javascript has no native support for big endian buffers. " +
                    "In this case, you can pass an explicit type argument. " +
                    "For instance, `getBuffer('dataview')` will return a `DataView`" +
                    "which has native support for reading big endian data. " +
                    "Alternatively, toJs will automatically convert the buffer " +
                    "to little endian.");
            }
            var numBytes = maxByteOffset - minByteOffset;
            if (numBytes !== 0 &&
                (startByteOffset % alignment !== 0 ||
                    minByteOffset % alignment !== 0 ||
                    maxByteOffset % alignment !== 0)) {
                throw new Error("Buffer does not have valid alignment for a ".concat(ArrayType.name));
            }
            var numEntries = numBytes / alignment;
            var offset = (startByteOffset - minByteOffset) / alignment;
            var data = void 0;
            if (numBytes === 0) {
                data = new ArrayType();
            }
            else {
                data = new ArrayType(HEAPU32.buffer, minByteOffset, numEntries);
            }
            for (var _i = 0, _b = strides.keys(); _i < _b.length; _i++) {
                var i = _b[_i];
                strides[i] /= alignment;
            }
            success = (!!1);
            var result = Object.create(PyBuffer.prototype, Object.getOwnPropertyDescriptors({
                offset: offset,
                readonly: readonly,
                format: format,
                itemsize: itemsize,
                ndim: shape.length,
                nbytes: numBytes,
                shape: shape,
                strides: strides,
                data: data,
                c_contiguous: c_contiguous,
                f_contiguous: f_contiguous,
                _view_ptr: view_ptr,
                _released: (!!0)
            }));
            // Module.bufferFinalizationRegistry.register(result, view_ptr, result);
            return result;
        }
        finally {
            if (!success) {
                try {
                    module_js_1.Module._PyBuffer_Release(view_ptr);
                    module_js_1.Module._PyMem_Free(view_ptr);
                }
                catch (e) {
                    module_js_1.Module.fatal_error(e);
                }
            }
        }
    };
    return PyProxyBufferMethods;
}());
/**
 * @typedef {Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array} TypedArray;
 */
/**
 * A class to allow access to a Python data buffers from JavaScript. These are
 * produced by :any:`PyProxy.getBuffer` and cannot be constructed directly.
 * When you are done, release it with the :any:`release <PyBuffer.release>`
 * method.  See
 * `Python buffer protocol documentation
 * <https://docs.python.org/3/c-api/buffer.html>`_ for more information.
 *
 * To find the element ``x[a_1, ..., a_n]``, you could use the following code:
 *
 * .. code-block:: js
 *
 *    function multiIndexToIndex(pybuff, multiIndex){
 *       if(multindex.length !==pybuff.ndim){
 *          throw new Error("Wrong length index");
 *       }
 *       let idx = pybuff.offset;
 *       for(let i = 0; i < pybuff.ndim; i++){
 *          if(multiIndex[i] < 0){
 *             multiIndex[i] = pybuff.shape[i] - multiIndex[i];
 *          }
 *          if(multiIndex[i] < 0 || multiIndex[i] >= pybuff.shape[i]){
 *             throw new Error("Index out of range");
 *          }
 *          idx += multiIndex[i] * pybuff.stride[i];
 *       }
 *       return idx;
 *    }
 *    console.log("entry is", pybuff.data[multiIndexToIndex(pybuff, [2, 0, -1])]);
 *
 * .. admonition:: Contiguity
 *    :class: warning
 *
 *    If the buffer is not contiguous, the ``data`` TypedArray will contain
 *    data that is not part of the buffer. Modifying this data may lead to
 *    undefined behavior.
 *
 * .. admonition:: Readonly buffers
 *    :class: warning
 *
 *    If ``buffer.readonly`` is ``true``, you should not modify the buffer.
 *    Modifying a readonly buffer may lead to undefined behavior.
 *
 * .. admonition:: Converting between TypedArray types
 *    :class: warning
 *
 *    The following naive code to change the type of a typed array does not
 *    work:
 *
 *    .. code-block:: js
 *
 *        // Incorrectly convert a TypedArray.
 *        // Produces a Uint16Array that points to the entire WASM memory!
 *        let myarray = new Uint16Array(buffer.data.buffer);
 *
 *    Instead, if you want to convert the output TypedArray, you need to say:
 *
 *    .. code-block:: js
 *
 *        // Correctly convert a TypedArray.
 *        let myarray = new Uint16Array(
 *            buffer.data.buffer,
 *            buffer.data.byteOffset,
 *            buffer.data.byteLength
 *        );
 */
var PyBuffer = /** @class */ (function () {
    function PyBuffer() {
        /**
         * The offset of the first entry of the array. For instance if our array
         * is 3d, then you will find ``array[0,0,0]`` at
         * ``pybuf.data[pybuf.offset]``
         * @type {number}
         */
        this.offset;
        /**
         * If the data is readonly, you should not modify it. There is no way
         * for us to enforce this, but it may cause very weird behavior.
         * @type {boolean}
         */
        this.readonly;
        /**
         * The format string for the buffer. See `the Python documentation on
         * format strings
         * <https://docs.python.org/3/library/struct.html#format-strings>`_.
         * @type {string}
         */
        this.format;
        /**
         * How large is each entry (in bytes)?
         * @type {number}
         */
        this.itemsize;
        /**
         * The number of dimensions of the buffer. If ``ndim`` is 0, the buffer
         * represents a single scalar or struct. Otherwise, it represents an
         * array.
         * @type {number}
         */
        this.ndim;
        /**
         * The total number of bytes the buffer takes up. This is equal to
         * ``buff.data.byteLength``.
         * @type {number}
         */
        this.nbytes;
        /**
         * The shape of the buffer, that is how long it is in each dimension.
         * The length will be equal to ``ndim``. For instance, a 2x3x4 array
         * would have shape ``[2, 3, 4]``.
         * @type {number[]}
         */
        this.shape;
        /**
         * An array of of length ``ndim`` giving the number of elements to skip
         * to get to a new element in each dimension. See the example definition
         * of a ``multiIndexToIndex`` function above.
         * @type {number[]}
         */
        this.strides;
        /**
         * The actual data. A typed array of an appropriate size backed by a
         * segment of the WASM memory.
         *
         * The ``type`` argument of :any:`PyProxy.getBuffer`
         * determines which sort of ``TypedArray`` this is. By default
         * :any:`PyProxy.getBuffer` will look at the format string to determine the most
         * appropriate option.
         * @type {TypedArray}
         */
        this.data;
        /**
         * Is it C contiguous?
         * @type {boolean}
         */
        this.c_contiguous;
        /**
         * Is it Fortran contiguous?
         * @type {boolean}
         */
        this.f_contiguous;
        throw new TypeError("PyBuffer is not a constructor");
    }
    /**
     * Release the buffer. This allows the memory to be reclaimed.
     */
    PyBuffer.prototype.release = function () {
        if (this._released) {
            return;
        }
        // Module.bufferFinalizationRegistry.unregister(this);
        try {
            module_js_1.Module._PyBuffer_Release(this._view_ptr);
            module_js_1.Module._PyMem_Free(this._view_ptr);
        }
        catch (e) {
            module_js_1.Module.fatal_error(e);
        }
        this._released = (!!1);
        this.data = null;
    };
    return PyBuffer;
}());
exports.PyBuffer = PyBuffer;
